<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcards de Conceptos</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
            margin: 0;
            overflow-y: scroll; /* Permite scroll vertical */
            /* Evita el scroll horizontal cuando la barra lateral está oculta */
            overflow-x: hidden; 
        }

        h1 {
            color: #0056b3;
            margin-bottom: 30px;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 800px;
            justify-content: center;
            position: relative; /* Para el posicionamiento de las sugerencias */
        }

        .controls input[type="text"] {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            flex-grow: 1;
            font-size: 1rem;
            position: relative;
            z-index: 2; /* Asegura que el input esté sobre las sugerencias */
        }

        .controls button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
            z-index: 1;
        }

        .controls button:hover {
            background-color: #0056b3;
        }

        /* Sugerencias de búsqueda */
        #searchResults {
            position: absolute;
            top: 100%; /* Debajo del input */
            left: 0;
            right: 0;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10; /* Por encima de las flashcards */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            display: none; /* Oculto por defecto */
        }

        .search-result-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .search-result-item:hover {
            background-color: #f0f0f0;
        }

        .flashcard-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4 columnas */
            gap: 20px;
            width: 100%;
            max-width: 1200px; /* Ajusta según sea necesario para 4 columnas */
            justify-content: center;
            padding: 20px 0;
        }

        .flashcard-container {
            perspective: 1000px;
            height: 200px; /* Altura fija para todas las tarjetas */
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid transparent; /* Para el foco */
            border-radius: 10px;
            box-sizing: border-box;
            cursor: pointer; /* Indica que es clicable */
        }

        .flashcard-container.focused {
            border-color: #007bff; /* Color de borde para la tarjeta enfocada */
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.5);
        }

        .flashcard {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            /* La animación de volteo se mantiene en caso de querer implementarla para la tarjeta grande o en otro contexto */
            transition: transform 0.6s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
            text-align: center;
            word-wrap: break-word;
            overflow: hidden; /* Para asegurar que el texto no se desborde sin scrollbar */
        }

        .flashcard-front {
            background-color: #ffffff;
            color: #333;
            font-size: 1.3em;
            font-weight: bold;
            border: 2px solid #007bff;
        }

        .flashcard-back {
            background-color: #e9f7ff;
            color: #555;
            transform: rotateY(180deg);
            font-size: 1em;
            border: 2px solid #28a745;
            overflow-y: auto; /* Para contenido largo en el back */
        }

        /* Estilos para el overlay de tarjeta grande */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }

        .overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .large-card-container {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 70%;
            max-height: 80%;
            overflow-y: auto;
            position: relative;
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .overlay.active .large-card-container {
            transform: scale(1);
        }

        .large-card-front, .large-card-back {
            margin-bottom: 15px;
            font-size: 1.2em;
            line-height: 1.6;
        }

        .large-card-front {
            font-weight: bold;
            color: #0056b3;
            font-size: 1.5em;
        }

        .large-card-back {
            color: #333;
        }

        .large-card-back strong {
            color: #007bff;
        }

        /* --- ESTILOS PARA LA IA CHATBASE --- */
        #ask-ia-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #4CAF50; /* Un color distintivo */
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            font-size: 1.2em;
            font-weight: bold;
            z-index: 999; /* Por debajo del overlay de la tarjeta grande, pero visible */
            transition: background-color 0.3s ease;
        }

        #ask-ia-button:hover {
            background-color: #45a049;
        }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Oscurece el fondo */
            z-index: 1010; /* Por encima de la página, por debajo de la barra lateral */
            display: none; /* Oculto por defecto */
        }

        .sidebar {
            position: fixed;
            top: 0;
            right: -400px; /* Inicialmente fuera de la pantalla */
            width: 350px; /* Ancho promedio de la barra lateral */
            height: 100%;
            background-color: white;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
            transition: right 0.3s ease-in-out;
            z-index: 1020; /* Por encima de todo lo demás */
            display: flex;
            flex-direction: column;
        }

        .sidebar.open {
            right: 0; /* Desliza hacia adentro */
        }

        .sidebar-header {
            padding: 15px;
            background-color: #f0f0f0;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h2 {
            margin: 0;
            font-size: 1.2em;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #333;
        }

        .chatbase-container {
            flex-grow: 1; /* Permite que el contenedor del chat ocupe el espacio restante */
            overflow: hidden; /* Asegura que el chat de Chatbase no se desborde */
            display: flex; /* Usar flexbox para asegurar que el iframe se ajuste bien */
            flex-direction: column;
        }

        /* Asegúrate de que el widget de Chatbase se ajuste al contenedor */
        /* Esto sobreescribe los estilos que Chatbase podría intentar aplicar para su burbuja flotante */
        [id^='chatbase-bubble-root'], 
        [id^='chatbase-widget-bubble-'],
        [id^='chatbase-widget-bubble-'] iframe {
            position: relative !important;
            width: 100% !important;
            height: 100% !important;
            right: auto !important;
            bottom: auto !important;
            left: auto !important;
            top: auto !important;
            transform: none !important;
            box-shadow: none !important;
            border-radius: 0 !important;
            border: none !important;
        }
        
        /* Ocultar la burbuja original de Chatbase (si aún aparece) */
        .chatbase-bubble-open, /* Clase que Chatbase añade a su burbuja cuando está abierta */
        [id^='chatbase-widget-bubble-'] { /* El ID exacto de la burbuja flotante de Chatbase */
            display: none !important;
        }


        @media (max-width: 1024px) {
            .flashcard-grid {
                grid-template-columns: repeat(3, 1fr); /* 3 columnas en pantallas medianas */
            }
        }

        @media (max-width: 768px) {
            .flashcard-grid {
                grid-template-columns: repeat(2, 1fr); /* 2 columnas en pantallas pequeñas */
            }

            .large-card-container {
                max-width: 90%;
                padding: 20px;
            }

            .sidebar {
                width: 280px; /* Reducir el ancho de la barra lateral en pantallas pequeñas */
                right: -300px;
            }
        }

        @media (max-width: 480px) {
            .flashcard-grid {
                grid-template-columns: 1fr; /* 1 columna en pantallas muy pequeñas */
            }
        }
    </style>
</head>
<body>

    <h1>Flashcards de Conceptos</h1>

    <div class="controls">
        <input type="text" id="searchInput" placeholder="Buscar concepto...">
        <div id="searchResults"></div>
        <button onclick="shuffleCards()">Mezclar Tarjetas</button>
    </div>

    <div class="flashcard-grid" id="flashcardGrid">
        </div>

    <div class="overlay" id="overlay">
        <div class="large-card-container" id="largeCardContent">
            </div>
    </div>

    <div id="ask-ia-button">ASK-IA</div>

    <div class="sidebar-overlay" id="sidebar-overlay"></div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h2>Asistente IA</h2>
            <button class="close-btn" onclick="closeSidebar()">×</button>
        </div>
        <div class="chatbase-container" id="chatbase-widget-target">
            </div>
    </div>

    <script>
        const flashcardsData = [
            { front: "Conducta intergrupal", back: "Definición: Toda interacción entre miembros de grupos diferentes. Características: Basada en la pertenencia grupal. Incluye cooperación y conflicto. Sus determinantes son sociales más que individuales." },
            { front: "Independencia de las diferencias individuales", back: "Definición: La conducta intergrupal no depende de rasgos de personalidad particulares. Características: Comportamientos similares entre individuos distintos por el simple hecho de pertenecer al grupo." },
            { front: "Independencia de los estados motivacionales", back: "Definición: La conducta intergrupal se produce al margen de motivaciones individuales concretas. Características: No es necesaria una motivación individual previa para que se generen sesgos grupales." },
            { front: "Identidad social", back: "Definición: Parte del autoconcepto derivado de la pertenencia a un grupo social. Características: Contiene valor y significado emocional. Relacionada con la autoestima. Evidencia: Tajfel y Turner: los individuos buscan maximizar la identidad social positiva." },
            { front: "Categorización", back: "Definición: Proceso de clasificar a las personas en grupos. Características: Reduce la complejidad social. Tiende a acentuar diferencias intergrupales y similitudes intragrupales." },
            { front: "Acentuación de diferencias", back: "Definición: Tendencia a exagerar diferencias entre grupos y similitudes dentro del grupo. Características: Proceso perceptivo básico. Influye en estereotipos." },
            { front: "Estereotipos", back: "Definición: Creencias compartidas sobre características de los miembros de un grupo. Características: Simplifican la percepción social. Son resistentes al cambio." },
            { front: "Polarización", back: "Definición: Tendencia a adoptar posiciones extremas en situaciones grupales. Características: Más extrema que las posiciones individuales previas. Evidencia: Moscovici y Zavalloni: discusiones grupales intensifican opiniones." },
            { front: "Etnocentrismo", back: "Definición: Consideración del propio grupo como centro de referencia. Características: Superioridad de la endogrupo. Inferiorización del exogrupo." },
            { front: "Sesgos intergrupales", back: "Definición: Preferencia sistemática hacia el propio grupo frente a otros. Características: Produce favoritismo endogrupal. Puede llevar a discriminación." },
            { front: "Prejuicio", back: "Definición: Actitud negativa hacia miembros de un grupo. Características: Componente afectivo. Basado en la pertenencia grupal." },
            { front: "Discriminación", back: "Definición: Comportamiento diferencial negativo hacia miembros de un grupo. Características: Manifiesta el prejuicio en la conducta." },
            { front: "Favoritismo endogrupal", back: "Definición: Tendencia a beneficiar al grupo propio. Características: Aún en ausencia de conflicto real. Evidencia: Paradigma del grupo mínimo de Tajfel: asignación arbitraria genera preferencias." },
            { front: "Paradigma del grupo mínimo", back: "Definición: Método experimental que asigna personas a grupos sin historia ni interacción. Características: Basta categorización mínima para generar favoritismo. Evidencia: Tajfel (1971): sujetos asignaban más recursos a su propio grupo." },
            { front: "Teoría de la identidad social (TIS)", back: "Definición: Explica cómo la pertenencia grupal define la identidad y motiva la diferenciación favorable. Características: Identidad social positiva contribuye a la autoestima. Genera comparación intergrupal." },
            { front: "Teoría realista del conflicto (TRC)", back: "Definición: Postula que el conflicto intergrupal surge de la competencia por recursos limitados. Características: Cooperación reduce hostilidad. Evidencia: Sherif: interdependencia negativa provoca conflicto; interdependencia positiva, cooperación." },
            { front: "Interdependencia positiva (cooperación)", back: "Definición: Situación en que los objetivos de los grupos son compartidos. Características: Reduce prejuicio. Fomenta colaboración." },
            { front: "Interdependencia negativa (competición)", back: "Definición: Situación en que los objetivos de los grupos son incompatibles. Características: Origina hostilidad." },
            { front: "Teoría de juegos", back: "Definición: Modelo matemático para analizar interacciones estratégicas. Características: Considera ganancias y pérdidas. Evidencia: Dilema del prisionero como ejemplo clásico." },
            { front: "Dilema del prisionero", back: "Definición: Situación en que la decisión racional individual perjudica el beneficio colectivo. Características: Modelo de conflicto entre cooperación e interés propio." },
            { front: "Motivaciones subyacentes: intereses", back: "Definición: Razones basadas en beneficios materiales o tangibles." },
            { front: "Motivaciones subyacentes: valores", back: "Definición: Razones basadas en principios o creencias compartidas." },
            { front: "Motivaciones subyacentes: necesidades", back: "Definición: Razones basadas en carencias personales o grupales." },
            { front: "Estratificación social", back: "Definición: Organización jerárquica de grupos en la sociedad. Características: Define estatus y poder." },
            { front: "Poder", back: "Definición: Capacidad de un grupo de influir sobre otros. Características: Puede basarse en recursos o legitimidad." },
            { front: "Estatus", back: "Definición: Prestigio o reconocimiento social del grupo. Características: Independiente del poder material." },
            { front: "Peso numérico", back: "Definición: Tamaño relativo del grupo en la población. Características: Influye en la percepción social." },
            { front: "Altercentrismo", back: "Definición: Tendencia a centrarse en las perspectivas del otro grupo. Características: Puede reducir prejuicio y conflicto." },
            { front: "Patología grupal", back: "Definición: Atmosfera en la que un grupo normal puede generar comportamientos destructivos al combinar condiciones estructurales e ideológicas extremas. Características: Surge de la interacción de factores de podersumisión, rutinas burocráticas y sistemas ideológicos que legitiman la violencia. Evidencia: Atentado del 11M y masacre de Leganés, donde individuos “normales” cometieron actos extremos bajo la lógica de grupo." },
            { front: "Estructura de poder (condición estructural)", back: "Definición: Modo en que el poder y la autoridad se organizan dentro del grupo. Características: Alta centralización de las decisiones. Liderazgo autoritario. Evidencia: Los soldados de My Lai siguieron órdenes estrictas de un mando único." },
            { front: "Estructura de tarea (condición estructural)", back: "Definición: División y asignación minuciosa de funciones en el grupo. Características: Cada miembro se responsabiliza solo de su parte, reduciendo toma de decisiones individual." },
            { front: "Estructura de norma (condición estructural)", back: "Definición: Conjunto de reglas y rutinas que estandarizan procedimientos y conductas. Características: Rutinización mecánica de acciones, anulación de escrúpulos morales." },
            { front: "Percepción de amenaza (condición ideológica)", back: "Definición: Sensación de vulnerabilidad del endogrupo frente al exogrupo. Características: Alimenta miedo y cohesión interna para “defenderse”. Evidencia: Testimonios de guerrilleros que actuaron por temor a ser considerados traidores." },
            { front: "Culpabilización del exogrupo (condición ideológica)", back: "Definición: Atribuir al otro grupo la responsabilidad de agravios pasados o presentes. Características: Refuerza la justificación de la violencia como “venganza”." },
            { front: "Creencias devaluadoras (condición ideológica)", back: "Definición: Sistema de estereotipos que despersonaliza y deshumaniza al exogrupo. Subtipos: Despersonalización: Ignorar la identidad individual. Atribución de rasgos negativos: Suponer intenciones maliciosas. Deshumanización: Verlos como “no-humanos”. Evidencia: Fotografías de presos desnudos y forzados a actos degradantes en Abu Ghraib." },
            { front: "Apelación a altos fines (condición ideológica)", back: "Definición: Invocar valores o metas trascendentes (religión, patria) para legitimar la violencia. Características: Eleva moralmente acciones atroces como “necesarias”." },
            { front: "Obediencia ciega", back: "Definición: Cumplimiento incondicional de órdenes sin cuestionar su moralidad. Características: Ausencia de dilema; fusión con la autoridad. Evidencia: Teniente Calley y la masacre de My Lai, donde los soldados actuaron “solo cumpliendo órdenes”." },
            { front: "Desplazamiento de la responsabilidad", back: "Definición: Trasladar la culpa personal al remitente de la orden. Características: “Yo solo obedezco, no tomo decisiones”." },
            { front: "Desindividuación", back: "Definición: Pérdida de la identidad personal al diluirse en el rol grupal. Características: Anonimato psicológico, disminución de autocontrol. Evidencia: Experimento de la prisión de Stanford, donde “vigilantes” se tornaron sádicos en días." },
            { front: "Estigmatización de las víctimas", back: "Definición: Marcar al exogrupo como “enemigo” merecedor de castigo. Características: Facilita la agresión sin remordimientos." },
            { front: "Reducción de la empatía", back: "Definición: Desconexión emocional frente al sufrimiento ajeno. Características: Minimiza la consideración de daños infligidos." },
            { front: "Exclusión moral", back: "Definición: No aplicar principios éticos al exogrupo, viéndolo fuera del “círculo moral”. Características: Habilita tortura y asesinatos sistemáticos." },
            { front: "Autoridad", back: "Definición: Poder legítimo aceptado para ordenar y ser obedecido. Características: Legitimidad, derecho de mando y obligación de obedecer. Tres perspectivas: Weber: Dominación y obediencia como base de la autoridad. Kelman & Hamilton: Influencia social legítima en contextos políticos. Milgram: Control social situacional que induce obediencia. Procesos de influencia social (subtipos de autoridad) Sumisión: Obedecer para obtener recompensa o evitar castigo. Identificación: Adoptar el modelo de rol del agente de influencia. Internalización: Alinear los valores propios con los del agente de influencia. Evidencia: Testimonios de guerrilleros que comparten ideales por identificación." },
            { front: "Crímenes de obediencia", back: "Definición: Actos extremos de violencia cometidos bajo órdenes legítimas. Características: Combinan autoridad, rutina y deshumanización. Casos: Masacre de My Lai (1968). El Mozote, El Salvador (1981). Torturas de Abu Ghraib (2003-04)." },
            { front: "Racionalidad del mal", back: "Definición: Planificación meticulosa de la violencia como estrategia para maximizar impacto. Características: Frialdad técnica, análisis de alternativas, selección de métodos más destructivos." },
            { front: "Metaverso", back: "Definición: Un espacio virtual colectivo y persistente, creado por la convergencia de la realidad física aumentada y entornos digitales, donde las acciones de los usuarios en un mundo impactan el otro y viceversa. Características principales: Inmersividad y continuidad temporal. Interactividad en tiempo real. Convergencia de tecnologías (VR, AR, IA, blockchain). Personalización mediante avatares y “gemelos digitales”. Elementos: Hardware: cascos, gafas híbridas, sensores de movimiento. Software: motores gráficos 3D, algoritmos de sincronización sensorial. Infraestructura: redes de alta velocidad, plataformas descentralizadas. Subtipos: Plataforma (arquitectura donde ocurren interacciones). Mundo (espacios virtuales con narrativas propias). Evidencia / Caso: Neal Stephenson (1992) lo acuñó en Snow Crash. Park & Kim (2022) describen apps de Metaverso en industria y educación." },
            { front: "Codificación Predictiva y Neurociencia del Metaverso", back: "Definición: Aplicación del modelo de codificación predictiva del cerebro (anticipa y corrige percepciones) a entornos virtuales que simulan sensaciones del mundo real. Características principales: Predicción de resultados sensoriales. Corrección de errores mediante retroalimentación en tiempo real. Sincronía entre modelo digital y representación interna del usuario. Elementos: Representación digital de cuerpo y entorno. Sensores (cámaras, acelerómetros). Algoritmos de renderizado y física. Subtipos: VR tradicional vs realidad aumentada híbrida. Evidencia / Caso: Clark (2013), Hohwy (2013) en codificación predictiva. Riva & Wiederhold (2022) vinculan VR y predicción cerebral." },
            { front: "“Humane Metaverse”: Marco Teórico", back: "Definición: Visión de un Metaverso que potencie valores humanos (empatía, comunidad) y mitigue debilidades de redes sociales tradicionales. Características principales: Enfoque en bienestar y ética. Sinergia entre neurociencia y tecnología. Diseño centrado en usuario y valores (DEI). Elementos: Predicción cognitiva como base de presencia. Co-presencia social y narrativas compartidas. Regulación ética (privacidad, justicia algorítmica). Evidencia / Caso: Riva et al. exploran neuromodelos de comunidades físicas vs digitales. De Florio & Frigerio distinguen “Metaverso como plataforma” y “como mundo”." },
            { front: "Realidad Extendida en Educación (Proyecto Metaversity)", back: "Definición: Integración de XR (realidad virtual, aumentada y mixta) para aprendizaje activo y experiencial. Características principales: Aprendizaje interactivo y colaborativo. Espacios virtuales para razonamiento y resolución de problemas. Retos de costos, accesibilidad e inclusión. Elementos: Frameworks pedagógicos (design thinking). Herramientas de creación de contenidos XR. Formación docente y soporte técnico. Evidencia / Caso: Gaggioli et al.: Metaversity usa design thinking para involucrar a todos los stakeholders. Di Natale et al.: Modelo EECM para aceptación de IVR en curso italiano." },
            { front: "Factores en Eventos Académicos Metaverso", back: "Definición: Variables que influyen en la experiencia de académicos en plataformas tipo Gather.Town (Metaverso “ligero”). Características principales: Presencia social y autoeficacia tecnológica como predictores de interacciones. Satisfacción afectada por motivación interna más que por co-presencia. Evidencia / Caso: Fangying Lo et al.: Alta presencia social → más interacciones académicas; la autoeficacia impulsa satisfacción." },
            { front: "Autoexpansión en VR", back: "Definición: Extensión del yo mediante experiencias inmersivas. Riesgo: Disonancia identidad real–virtual reduce autoestima si falta coherencia. Evidencia: Jang et al. (VRChat, N=486)." },
            { front: "Agentes Virtuales y Conducta de Riesgo", back: "Definición: Influencia de avatares en decisiones de adolescentes. Resultados: Mayor toma de riesgos bajo “nudge” de agentes AI. Evidencia: Di Dio et al. (BART, N=113)." },
            { front: "Perspectivas “Indie” del Metaverso", back: "Definición: Visión crítica y paródica desde desarrolladores de videojuegos independientes. Características principales: Escepticismo sobre la comercialización. Modelos alternativos enfocados en comunidad y no-comercialización. Caso: “The Endless Forest”: juego sin objetivos ni lenguaje que prioriza comunicación no verbal." },
            { front: "Metaverso en Salud y Bienestar Mental (“MEDverse”)", back: "Definición: Uso de entornos inmersivos para intervenciones en trastornos psicológicos y promoción de salud. Características principales: Avatares corporales para terapias de imagen corporal y autismo. Potencial de integración de IA, IoT y blockchain. Necesidad de marco socialneurocientífico. Evidencia / Caso: Cerasa et al.: VR validada en dolor/ansiedad; MEDverse busca enriquecer con feedback multisensorial." },
            { front: "Modelos de Negocio y Organizaciones en el Metaverso", back: "Definición: Implicaciones gerenciales al incorporar espacios virtuales en procesos empresariales. Características principales: Transición a Web 3.0 y blockchain. Nuevos modelos de HR (formación, reclutamiento) y experiencia cliente. Desafíos regulatorios y éticos en IA. Evidencia / Caso: Frigerio & Rajola: Web 3.0 como reacción a Web 2.0; potencial en banca y trabajo remoto inmersivo." },
            { front: "Comunidades Físicas vs Digitales: El “WeMode”", back: "Definición: Modo cognitivo colectivo caracterizado por sincronía conductual, empatía y narrativas compartidas. Características de comunidades físicas: Anclaje a lugares y límites que facilitan copresencia. Procesos neurobiológicos: células de lugar, oxitocina, sincronía intercerebral. Comunidades digitales: Basadas en intereses (“comunidades de práctica”), menos diversidad y “sabiduría de la multitud” polarizada. Falta copresencia reduce empatía extendida y motivación socia." }
        ]; /* cite: uploaded:index.html */

        const flashcardGrid = document.getElementById('flashcardGrid'); /* cite: uploaded:index.html */
        const searchInput = document.getElementById('searchInput'); /* cite: uploaded:index.html */
        const searchResults = document.getElementById('searchResults'); /* cite: uploaded:index.html */
        const overlay = document.getElementById('overlay'); /* cite: uploaded:index.html */
        const largeCardContent = document.getElementById('largeCardContent'); /* cite: uploaded:index.html */

        let currentFlashcards = [...flashcardsData]; // Copia de los datos originales
        let focusedCardIndex = -1; // Para la navegación con flechas

        // Helper para asegurar que ninguna tarjeta esté visualmente enfocada
        function clearAllFocus() { /* cite: uploaded:index.html */
            const cards = flashcardGrid.querySelectorAll('.flashcard-container'); /* cite: uploaded:index.html */
            cards.forEach(card => card.classList.remove('focused')); /* cite: uploaded:index.html */
        }

        function createFlashcardElement(cardData, index) { /* cite: uploaded:index.html */
            const cardContainer = document.createElement('div'); /* cite: uploaded:index.html */
            cardContainer.classList.add('flashcard-container'); /* cite: uploaded:index.html */
            cardContainer.dataset.index = index; // Usamos el índice original para referenciar los datos

            const flashcard = document.createElement('div'); /* cite: uploaded:index.html */
            flashcard.classList.add('flashcard'); /* cite: uploaded:index.html */
            flashcard.dataset.cardIndex = index; // También en la flashcard misma para fácil acceso
            
            const flashcardFront = document.createElement('div'); /* cite: uploaded:index.html */
            flashcardFront.classList.add('flashcard-front'); /* cite: uploaded:index.html */
            flashcardFront.textContent = cardData.front; /* cite: uploaded:index.html */

            const flashcardBack = document.createElement('div'); /* cite: uploaded:index.html */
            flashcardBack.classList.add('flashcard-back'); /* cite: uploaded:index.html */
            flashcardBack.innerHTML = cardData.back; /* cite: uploaded:index.html */

            flashcard.appendChild(flashcardFront); /* cite: uploaded:index.html */
            flashcard.appendChild(flashcardBack); /* cite: uploaded:index.html */
            cardContainer.appendChild(flashcard); /* cite: uploaded:index.html */

            // Un solo click en el contenedor abre la tarjeta grande
            cardContainer.addEventListener('click', (event) => { /* cite: uploaded:index.html */
                showLargeCard(cardData); /* cite: uploaded:index.html */
            });

            return cardContainer; /* cite: uploaded:index.html */
        }

        function renderFlashcards(cardsToRender) { /* cite: uploaded:index.html */
            clearAllFocus(); // Limpiar cualquier foco existente antes de renderizar
            flashcardGrid.innerHTML = ''; // Limpiar el grid antes de renderizar
            cardsToRender.forEach((card, index) => { /* cite: uploaded:index.html */
                flashcardGrid.appendChild(createFlashcardElement(card, index)); /* cite: uploaded:index.html */
            });
            // El foco se gestiona por updateFocusedCard después de esta función.
        }

        function shuffleCards() { /* cite: uploaded:index.html */
            currentFlashcards = [...flashcardsData]; // Resetear a los datos originales antes de mezclar
            for (let i = currentFlashcards.length - 1; i > 0; i--) { /* cite: uploaded:index.html */
                const j = Math.floor(Math.random() * (i + 1)); /* cite: uploaded:index.html */
                [currentFlashcards[i], currentFlashcards[j]] = [currentFlashcards[j], currentFlashcards[i]]; /* cite: uploaded:index.html */
            }
            renderFlashcards(currentFlashcards); /* cite: uploaded:index.html */
            focusedCardIndex = -1; // Resetear el foco al mezclar
            updateFocusedCard(focusedCardIndex); // Asegurar que ninguna tarjeta esté visualmente enfocada
        }

        function displaySearchResults(results) { /* cite: uploaded:index.html */
            searchResults.innerHTML = ''; /* cite: uploaded:index.html */
            if (results.length > 0) { /* cite: uploaded:index.html */
                searchResults.style.display = 'block'; /* cite: uploaded:index.html */
                results.forEach((card) => { /* cite: uploaded:index.html */
                    const resultItem = document.createElement('div'); /* cite: uploaded:index.html */
                    resultItem.classList.add('search-result-item'); /* cite: uploaded:index.html */
                    resultItem.textContent = card.front; /* cite: uploaded:index.html */
                    // Almacenar el índice real de la tarjeta en flashcardsData para poder mostrarla
                    resultItem.dataset.cardIndex = flashcardsData.indexOf(card); /* cite: uploaded:index.html */
                    resultItem.onclick = () => { /* cite: uploaded:index.html */
                        searchInput.value = card.front; // Rellenar el input con el nombre completo
                        searchResults.style.display = 'none'; // Ocultar sugerencias
                        showLargeCard(card); // Desplegar la tarjeta grande de la opción clickeada
                        focusedCardIndex = flashcardsData.indexOf(card); // Enfocar la tarjeta seleccionada
                        updateFocusedCard(focusedCardIndex); /* cite: uploaded:index.html */
                    };
                    searchResults.appendChild(resultItem); /* cite: uploaded:index.html */
                });
            } else {
                searchResults.style.display = 'none'; /* cite: uploaded:index.html */
            }
        }

        function handleSearchInput() { /* cite: uploaded:index.html */
            const searchTerm = searchInput.value.toLowerCase(); /* cite: uploaded:index.html */

            if (searchTerm.length > 0) { /* cite: uploaded:index.html */
                const matchingConcepts = flashcardsData.filter(card => /* cite: uploaded:index.html */
                    card.front.toLowerCase().includes(searchTerm) /* cite: uploaded:index.html */
                );
                displaySearchResults(matchingConcepts); /* cite: uploaded:index.html */
            } else {
                searchResults.style.display = 'none'; /* cite: uploaded:index.html */
                currentFlashcards = [...flashcardsData]; // Vuelve a mostrar todas las tarjetas si el input está vacío
                renderFlashcards(currentFlashcards); /* cite: uploaded:index.html */
                focusedCardIndex = -1; // Resetear el foco
                updateFocusedCard(focusedCardIndex); // Asegurar que no haya foco visual
            }
        }

        function performFullSearch() { /* cite: uploaded:index.html */
            const searchTerm = searchInput.value.toLowerCase(); /* cite: uploaded:index.html */
            searchResults.style.display = 'none'; // Ocultar sugerencias al presionar Enter

            if (searchTerm === "") { /* cite: uploaded:index.html */
                currentFlashcards = [...flashcardsData]; /* cite: uploaded:index.html */
                renderFlashcards(currentFlashcards); /* cite: uploaded:index.html */
                focusedCardIndex = -1; /* cite: uploaded:index.html */
                updateFocusedCard(focusedCardIndex); /* cite: uploaded:index.html */
                return; /* cite: uploaded:index.html */
            }

            const exactMatch = flashcardsData.find(card => card.front.toLowerCase() === searchTerm); /* cite: uploaded:index.html */
            if (exactMatch) { /* cite: uploaded:index.html */
                showLargeCard(exactMatch); /* cite: uploaded:index.html */
                // Si hay una coincidencia exacta y se muestra la tarjeta grande, re-renderizar todas las tarjetas
                // y enfocar la encontrada para que la navegación por flechas funcione bien después de cerrar el overlay
                currentFlashcards = [...flashcardsData]; // Asegurarse de que currentFlashcards tenga todas las originales
                renderFlashcards(currentFlashcards); /* cite: uploaded:index.html */
                focusedCardIndex = flashcardsData.indexOf(exactMatch); // Enfocar la tarjeta encontrada
                updateFocusedCard(focusedCardIndex); /* cite: uploaded:index.html */
                return; /* cite: uploaded:index.html */
            }

            const filteredCards = flashcardsData.filter(card => /* cite: uploaded:index.html */
                card.front.toLowerCase().includes(searchTerm) || /* cite: uploaded:index.html */
                card.back.toLowerCase().includes(searchTerm) /* cite: uploaded:index.html */
            );

            // Priorizar las tarjetas cuya parte frontal coincide con el término de búsqueda
            filteredCards.sort((a, b) => { /* cite: uploaded:index.html */
                const aMatchesFront = a.front.toLowerCase().includes(searchTerm); /* cite: uploaded:index.html */
                const bMatchesFront = b.front.toLowerCase().includes(searchTerm); /* cite: uploaded:index.html */

                if (aMatchesFront && !bMatchesFront) return -1; /* cite: uploaded:index.html */
                if (!aMatchesFront && bMatchesFront) return 1; /* cite: uploaded:index.html */
                return 0; /* cite: uploaded:index.html */
            });

            currentFlashcards = filteredCards; /* cite: uploaded:index.html */
            renderFlashcards(currentFlashcards); /* cite: uploaded:index.html */
            focusedCardIndex = currentFlashcards.length > 0 ? 0 : -1; // Enfocar la primera tarjeta si hay resultados
            updateFocusedCard(focusedCardIndex); /* cite: uploaded:index.html */
        }

        function showLargeCard(cardData) { /* cite: uploaded:index.html */
            largeCardContent.innerHTML = `
                <div class="large-card-front">${cardData.front}</div>
                <div class="large-card-back">${cardData.back}</div>
            `; /* cite: uploaded:index.html */
            overlay.classList.add('active'); /* cite: uploaded:index.html */
            document.body.style.overflow = 'hidden'; // Evita el scroll del cuerpo
        }

        function hideLargeCard() { /* cite: uploaded:index.html */
            overlay.classList.remove('active'); /* cite: uploaded:index.html */
            document.body.style.overflow = ''; // Restaura el scroll del cuerpo
            searchInput.focus(); // Devolver el foco al input de búsqueda al cerrar el overlay
        }

        // Navegación con teclado
        function updateFocusedCard(newIndex) { /* cite: uploaded:index.html */
            clearAllFocus(); // Siempre limpiar todos los focos antes de establecer uno nuevo

            const cards = flashcardGrid.querySelectorAll('.flashcard-container'); /* cite: uploaded:index.html */
            if (cards.length === 0) { /* cite: uploaded:index.html */
                focusedCardIndex = -1; /* cite: uploaded:index.html */
                return; /* cite: uploaded:index.html */
            }

            // Asegurarse de que el índice esté dentro de los límites
            newIndex = Math.max(0, Math.min(newIndex, cards.length - 1)); /* cite: uploaded:index.html */
            focusedCardIndex = newIndex; /* cite: uploaded:index.html */

            // Añadir foco a la nueva tarjeta si el índice es válido
            if (focusedCardIndex !== -1 && cards[focusedCardIndex]) { /* cite: uploaded:index.html */
                cards[focusedCardIndex].classList.add('focused'); /* cite: uploaded:index.html */
                // ScrollIntoView solo si la tarjeta no está visible
                cards[focusedCardIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' }); /* cite: uploaded:index.html */
            }
        }

        document.addEventListener('keydown', (e) => { /* cite: uploaded:index.html */
            // Si el overlay está activo, solo 'Escape' debe funcionar (para cerrarlo). Otras teclas no hacen nada.
            if (overlay.classList.contains('active')) { /* cite: uploaded:index.html */
                if (e.key === 'Escape') { /* cite: uploaded:index.html */
                    e.preventDefault(); // Prevenir el comportamiento predeterminado de Escape
                    hideLargeCard(); /* cite: uploaded:index.html */
                    focusedCardIndex = -1; // Deseleccionar la tarjeta después de cerrar la grande
                    updateFocusedCard(focusedCardIndex); // Asegurar que no haya foco visual
                }
                return; // Detener el procesamiento de otras teclas cuando el overlay está activo
            }
            
            // Lógica para cerrar la barra lateral de Chatbase con Escape
            if (sidebar.classList.contains('open') && e.key === 'Escape') {
                e.preventDefault();
                closeSidebar();
                return;
            }


            const numCols = 4; // Definido en CSS
            const numCards = currentFlashcards.length; /* cite: uploaded:index.html */

            if (numCards === 0) return; /* cite: uploaded:index.html */

            let newIndex = focusedCardIndex; // Inicializar con el índice enfocado actual

            // Check if the currently active element is the search input
            const isSearchInputFocused = document.activeElement === searchInput; /* cite: uploaded:index.html */

            switch (e.key) { /* cite: uploaded:index.html */
                case 'ArrowUp': /* cite: uploaded:index.html */
                    e.preventDefault(); // Evitar el scroll predeterminado de la página
                    newIndex -= numCols; /* cite: uploaded:index.html */
                    break; /* cite: uploaded:index.html */
                case 'ArrowDown': /* cite: uploaded:index.html */
                    e.preventDefault(); // Evitar el scroll predeterminado de la página
                    newIndex += numCols; /* cite: uploaded:index.html */
                    break; /* cite: uploaded:index.html */
                case 'ArrowLeft': /* cite: uploaded:index.html */
                    e.preventDefault(); /* cite: uploaded:index.html */
                    newIndex--; /* cite: uploaded:index.html */
                    break; /* cite: uploaded:index.html */
                case 'ArrowRight': /* cite: uploaded:index.html */
                    e.preventDefault(); /* cite: uploaded:index.html */
                    newIndex++; /* cite: uploaded:index.html */
                    break; /* cite: uploaded:index.html */
                case 'Enter': /* cite: uploaded:index.html */
                    e.preventDefault(); /* cite: uploaded:index.html */
                    if (isSearchInputFocused) { /* cite: uploaded:index.html */
                        // If Enter is pressed while search input is focused, perform full search
                        performFullSearch(); /* cite: uploaded:index.html */
                    } else if (focusedCardIndex !== -1) { /* cite: uploaded:index.html */
                        // If Enter is pressed and a card is focused (and search input is NOT focused), open the card
                        showLargeCard(currentFlashcards[focusedCardIndex]); /* cite: uploaded:index.html */
                    }
                    return; // Retornar después de manejar Enter para evitar llamadas redundantes
                case 'Escape': /* cite: uploaded:index.html */
                    // Este bloque es para cuando el overlay NO está activo
                    e.preventDefault(); /* cite: uploaded:index.html */
                    searchInput.value = ''; /* cite: uploaded:index.html */
                    searchResults.style.display = 'none'; /* cite: uploaded:index.html */
                    currentFlashcards = [...flashcardsData]; // Resetear a todas las tarjetas originales
                    renderFlashcards(currentFlashcards); /* cite: uploaded:index.html */
                    focusedCardIndex = -1; // Deseleccionar todas las tarjetas
                    updateFocusedCard(focusedCardIndex); // Asegurar que ninguna tarjeta esté visualmente enfocada
                    return; // Retornar después de manejar Escape
            }

            // Solo actualizar el foco si el índice realmente cambió o si es la primera vez que se establece un foco
            if (newIndex !== focusedCardIndex || focusedCardIndex === -1) { /* cite: uploaded:index.html */
                updateFocusedCard(newIndex); /* cite: uploaded:index.html */
            }
        });

        // Event Listeners
        searchInput.addEventListener('input', handleSearchInput); /* cite: uploaded:index.html */
        // Removed searchInput.addEventListener('keydown', ...) for Enter, now handled globally

        overlay.addEventListener('click', (e) => { /* cite: uploaded:index.html */
            if (e.target === overlay) { // Solo cierra si se clickea el fondo del overlay
                hideLargeCard(); /* cite: uploaded:index.html */
            }
        });


        // Cargar las tarjetas al iniciar
        document.addEventListener('DOMContentLoaded', () => { /* cite: uploaded:index.html */
            renderFlashcards(flashcardsData); /* cite: uploaded:index.html */
            focusedCardIndex = 0; // Iniciar con la primera tarjeta enfocada
            updateFocusedCard(focusedCardIndex); /* cite: uploaded:index.html */
        });

        /* --- LÓGICA PARA LA BARRA LATERAL DE LA IA --- */
        const askIaButton = document.getElementById('ask-ia-button');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const chatbaseContainer = document.getElementById('chatbase-widget-target');

        function openSidebar() {
            sidebar.classList.add('open');
            sidebarOverlay.style.display = 'block'; // Mostrar el overlay
            // Opcional: Ocultar el botón "ASK-IA" cuando la barra lateral está abierta
            askIaButton.style.display = 'none';
        }

        function closeSidebar() {
            sidebar.classList.remove('open');
            sidebarOverlay.style.display = 'none'; // Ocultar el overlay
            // Opcional: Mostrar el botón "ASK-IA" cuando la barra lateral está cerrada
            askIaButton.style.display = 'block';
        }

        askIaButton.addEventListener('click', openSidebar);
        sidebarOverlay.addEventListener('click', closeSidebar); // Cerrar al hacer clic en el overlay

        // Se añadió la lógica de Escape para la barra lateral en el keydown handler existente

        // Cargar el script de Chatbase DENTRO del contenedor de la barra lateral
        // Esto es crucial para que el widget se renderice dentro de la barra lateral.
        (function(){
            if(!window.chatbase||window.chatbase("getState")!=="initialized"){
                window.chatbase=(...arguments)=>{if(!window.chatbase.q){window.chatbase.q=[]}window.chatbase.q.push(arguments)};
                window.chatbase=new Proxy(window.chatbase,{get(target,prop){if(prop==="q"){return target.q}return(...args)=>target(prop,...args)}})
            }
            const onLoad=function(){
                const script=document.createElement("script");
                script.src="https://www.chatbase.co/embed.min.js";
                script.id="b8G58Dmvkjy4TIClKQmn2"; // Mantener la ID de Chatbase si es necesaria para su funcionamiento interno
                script.domain="www.chatbase.co";
                
                // Adjuntar el script al contenedor de la barra lateral, no al body
                chatbaseContainer.appendChild(script); 

                // Puedes añadir aquí lógica adicional si necesitas manipular el widget de Chatbase
                // una vez que esté cargado. Por ejemplo, forzar su visualización si no lo hace por defecto.
                script.onload = () => {
                    // Si Chatbase ofrece un método para "abrir" el chat incrustado, lo llamarías aquí.
                    // Ejemplo (no garantizado para Chatbase): window.chatbase('openChat');
                };
            };
            if(document.readyState==="complete"){onLoad()}else{window.addEventListener("load",onLoad)}
        })();
    </script>
</body>
</html>